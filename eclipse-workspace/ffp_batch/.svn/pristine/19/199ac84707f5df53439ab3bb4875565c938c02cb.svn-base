package com.forms.batch.job.unit.iclfps.payment;

import java.io.File;
import java.io.FilenameFilter;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Collections;
import java.util.Comparator;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import com.forms.ffp.adaptor.define.FFPJaxbConstants;
import com.forms.ffp.adaptor.jaxb.iclfps.fps_envelope_01.BatchInformation;
import com.forms.ffp.adaptor.jaxb.iclfps.fps_envelope_01.FpsMessageEnvelope;
import com.forms.ffp.adaptor.jaxb.iclfps.fps_envelope_01.ISO20022BusinessDataV01;
import com.forms.ffp.adaptor.jaxb.iclfps.head_001_001_01.BusinessApplicationHeaderV01;
import com.forms.ffp.adaptor.jaxb.iclfps.pacs_008_001_06.BranchAndFinancialInstitutionIdentification51;
import com.forms.ffp.adaptor.jaxb.iclfps.pacs_008_001_06.CashAccount241;
import com.forms.ffp.adaptor.jaxb.iclfps.pacs_008_001_06.CreditTransferTransaction251;
import com.forms.ffp.adaptor.jaxb.iclfps.pacs_008_001_06.GenericOrganisationIdentification11;
import com.forms.ffp.adaptor.jaxb.iclfps.pacs_008_001_06.GenericPersonIdentification11;
import com.forms.ffp.bussiness.iclfps.pacs008.FFPMsgVO_Pacs008_CdtTrfTxInf;
import com.forms.ffp.bussiness.iclfps.pacs008.FFPMsgVO_Pacs008_CdtTrfTxInf.CdtrOrgIdOth;
import com.forms.ffp.bussiness.iclfps.pacs008.FFPMsgVO_Pacs008_CdtTrfTxInf.CdtrPrvtIdOth;
import com.forms.ffp.bussiness.iclfps.pacs008.FFPMsgVO_Pacs008_CdtTrfTxInf.ChargeInfo;
import com.forms.ffp.bussiness.iclfps.pacs008.FFPMsgVO_Pacs008_CdtTrfTxInf.DbtrOrgIdOth;
import com.forms.ffp.bussiness.iclfps.pacs008.FFPMsgVO_Pacs008_CdtTrfTxInf.DbtrPrvtIdOth;
import com.forms.ffp.bussiness.iclfps.pacs008.FFPMsgVo_Pacs008;
import com.forms.ffp.core.define.FFPStatus;
import com.forms.ffp.core.msg.iclfps.FFPHkiclMessageConverter;
import com.forms.framework.BatchBaseJob;
import com.forms.framework.exception.BatchJobException;
import com.forms.framework.log.BatchLogger;
import com.forms.framework.persistence.ConnectionManager;
import com.forms.framework.persistence.EntityManager;
import com.forms.framework.util.PatternUtil;

public class PaymentInwardFileReader extends BatchBaseJob
{
	private BatchLogger _logger = BatchLogger.getLogger(this.jobName, this.actionName, PaymentInwardFileReader.class);
	
	private int BATCH_SIZE = 500;
	private String filePath = null;
	private String fileNamePattern = null;
	
	public void init() throws BatchJobException
	{
		try
		{
			filePath = this.batchData + this.actionElement.element("parameters").elementText("local-file-path");
			fileNamePattern = this.actionElement.element("parameters").elementText("filename-pattern");
			
			PatternUtil patternUtil = new PatternUtil(this.batchAcDate);
			Map<String, String> replaceMap = new HashMap<String, String>();
			replaceMap.put("YYYYMMDD", this.batchAcDate.replaceAll("-", ""));
			replaceMap.put("clearingcode", this.clearingCode);
			fileNamePattern = patternUtil.patternReplace(replaceMap, fileNamePattern);
		}
		catch(Exception ip_e)
		{
			throw new BatchJobException(ip_e);
		}
	}

	@Override
	public boolean execute() throws BatchJobException
	{
		Date loc_startTime = Calendar.getInstance().getTime();
		_logger.info("read inward batch started at" + loc_startTime);
		_logger.info(String.format("Read inward batch date : %s", this.batchAcDate));
		_logger.info(String.format("Read inward batch file path : %s", filePath));
		try
		{
			File workingPath = new File(filePath);
//			final String filePattern = this.fileNamePattern;
			//1.Get all files in this batch time
			File[] readfiles = workingPath.listFiles(new FilenameFilter()
			{
				@Override
				public boolean accept(File dir, String name)
				{
					return name.matches(fileNamePattern);
				}
			});
			
			if(readfiles != null)
			{
				// query processed file list
				String loc_processedSql = "SELECT FILE_NAME FROM TB_BH_PROCESSED_FILE ORDER BY FILE_NAME";
				List<Object[]> loc_tmpList = EntityManager.queryArrayList(loc_processedSql);
				String[] processedFileList = new String[loc_tmpList.size()];
				if(loc_tmpList != null)
				{
					for(int i = 0; i < loc_tmpList.size(); i ++)
						processedFileList[i] = (String)(loc_tmpList.get(i)[0]);
				}
				
				List<File> loc_fileList = new ArrayList<>();
				for(File loc_tmpFile : readfiles)
				{
					String loc_filename = loc_tmpFile.getName();
					if(Arrays.binarySearch(processedFileList, loc_filename) >= 0)
					{
						_logger.warn(loc_filename + " processed!!!");
					}
					else
					{
						loc_fileList.add(loc_tmpFile);
					}
				}
				
				if(loc_fileList.size() > 0)
				{
					// DELETE DATA FROM TMP TABLE
					String loc_deleteSql = "DELETE FROM TB_INWARD_DATA WHERE FILE_NAME IN(";
					for(int index = 0; index < loc_fileList.size(); index ++)
					{
						loc_deleteSql = loc_deleteSql + "'" + loc_fileList.get(index).getName() + "'" ;
						if(index < loc_fileList.size() - 1)
							loc_deleteSql = loc_deleteSql + ",";
						else
							loc_deleteSql = loc_deleteSql + ")";
					}
					EntityManager.update(loc_deleteSql);
					
					Map<String, List<ISO20022BusinessDataV01>> map = this.readFile(loc_fileList);
					this.processor(map);
					
					String loc_sql = "INSERT INTO TB_BH_PROCESSED_FILE(FILE_NAME, PROCESSED_TS) VALUES (?,?)";
					// insert processed file & delete files
					for(File tmp : loc_fileList)
					{
						EntityManager.update(loc_sql, tmp.getName(), loc_startTime);
						tmp.delete();
					}
				}
			}
			
			Date loc_endTime = Calendar.getInstance().getTime();
			_logger.info("read inward batch end at" + loc_endTime);
			_logger.info("read inward batch file use " + (loc_endTime.getTime() - loc_startTime.getTime()) / 1000);
			return true;
		}
		catch(Exception ip_e)
		{
			throw new BatchJobException(ip_e);
		}
	}
	
	private void processor(Map<String, List<ISO20022BusinessDataV01>> busiDataMap) throws Exception
	{
		_logger.info("Started processor inward batch file");
		
		//List<com.forms.ffp.adaptor.jaxb.iclfps.pacs_008_001_06.Document> pacs008list = new ArrayList<com.forms.ffp.adaptor.jaxb.iclfps.pacs_008_001_06.Document>();
		Iterator<String> fileKeyInfoItr = busiDataMap.keySet().iterator();
		
		Connection con = null;
		String batchId = null;//each batch time have the same batch id in all batch files
		
		try
		{
			//Get FFP Batch DB configuration, DB manager
			con = ConnectionManager.getInstance().getConnection();
			
			while(fileKeyInfoItr.hasNext())
			{
				String fileKeyInfo = fileKeyInfoItr.next();
				
				String fileName = fileKeyInfo.substring(0, fileKeyInfo.lastIndexOf("-"));
				if(batchId == null) batchId = fileKeyInfo.substring(fileKeyInfo.lastIndexOf("-") + 1);
				List<ISO20022BusinessDataV01> busiData = busiDataMap.get(fileKeyInfo);
				
				for(ISO20022BusinessDataV01 data : busiData)
				{
					BusinessApplicationHeaderV01 head = (BusinessApplicationHeaderV01)data.getContent().get(0).getValue();
					String messageType = head.getMsgDefIdr();
					String busiSvrType = head.getBizSvc().value();
					//pacs.008.001.06
					if(FFPJaxbConstants.JAXB_MSG_TYPE_PACS_008.compareTo(messageType) == 0) 
					{
						com.forms.ffp.adaptor.jaxb.iclfps.pacs_008_001_06.Document doc008 = 
												(com.forms.ffp.adaptor.jaxb.iclfps.pacs_008_001_06.Document)data.getContent().get(1).getValue();
						
						//pacs008list.add(doc008);
						
						//4.parse xml
						FFPMsgVo_Pacs008 pacs008 = parse008(doc008, fileName);
						
						//5.persistent in temp table
						persistentFileData(con, pacs008, fileName, batchId, busiSvrType);
					}
				}
			}
			
			//check FFP Agent status, CUT OFF/ON
			_logger.info("Ended processor inward batch file");
		}
		catch(Exception ex)
		{
			ex.printStackTrace();
			_logger.error("Process inward file error", ex);
			throw new BatchJobException(ex);
		}
		finally
		{
			if(con != null)
				con.close();
		}
	}
	
	//save file datas to temp table for re-run while exception
	public void persistentFileData(Connection con, FFPMsgVo_Pacs008 pacs008, String fileName, String batchId, String busiSvrType) throws Exception
	{
		String sql = "INSERT INTO TB_INWARD_DATA(BATCH_ID, STATUS, FILE_NAME, TRANSACTION_ID, END_TO_END_ID, FPS_REF, INSTRUCTION_ID, CATEGORY_PURPOSE, "
				+ "ACCT_VERF, SETTLEMENT_CUR, SETTLEMENT_AMT, SETTLEMENT_DATE, INSTRUCTED_CUR, INSTRUCTED_AMT, CHG_AGT_ID, CHG_AGT_BIC, CHG_CUR, CHG_AMT, "
				+ "DEBTOR_NAME, DEBTOR_ACCTNO, DEBTOR_ACCTNO_TYPE, DEBTOR_AGT_ID, DEBTOR_AGT_BIC, CREDITOR_NAME, CREDITOR_ACCTNO, CREDITOR_ACCTNO_TYPE,"
				+ "CREDITOR_AGT_ID, CREDITOR_AGT_BIC, PURPOSE_TYPE, PURPOSE_CODE, PURPOSE_OTHER, REMIT_INFO, MSG_INST_DATE, LAST_MODI_DATE, BIZ_SVC_TYPE) "
				+ "VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)";
		PreparedStatement pstm = null;
		try
		{
			List<FFPMsgVO_Pacs008_CdtTrfTxInf> txInfList = pacs008.getCdtTrfTxInfList();
			if(txInfList != null && txInfList.size() > 0)
			{
				pstm = con.prepareStatement(sql);
				con.setAutoCommit(false);
				int count = 0;
				for(FFPMsgVO_Pacs008_CdtTrfTxInf txInf : txInfList)
				{
					count ++;
					pstm.setString(1, batchId);
					pstm.setString(2, FFPStatus.TEMP_CREDIT_STATUS.INWARD_INITATE.getCode());
					pstm.setString(3, fileName);
					pstm.setString(4, txInf.getTxId());
					pstm.setString(5, txInf.getEndToEndId());
					pstm.setString(6, txInf.getClrSysRef());
					pstm.setString(7, txInf.getInstrId());//Instruction ID
					
					pstm.setString(8, txInf.getCtgyPurp());
					pstm.setString(9, txInf.getLclInstrm());
					pstm.setString(10, txInf.getIntrBkSttlmAmtCcy());
					pstm.setString(11, txInf.getIntrBkSttlmAmt());
					pstm.setTimestamp(12, new java.sql.Timestamp(new Date().getTime()));//settlement date
					pstm.setString(13, txInf.getInstdAmtCcy());
					pstm.setString(14, txInf.getInstdAmt());
					pstm.setString(15, null);		//charge info
					pstm.setString(16, null);
					pstm.setString(17, null);
					pstm.setString(18, null);
					pstm.setString(19, txInf.getDbtrNm());
					pstm.setString(20, txInf.getDbtrAcctId());
					pstm.setString(21, txInf.getDbtrAccSchmeNm());
					pstm.setString(22, txInf.getDbtrAgClrSysMmbId());//
					pstm.setString(23, txInf.getDbtrAgBICFI());
					pstm.setString(24, txInf.getCdtrNm());
					pstm.setString(25, txInf.getCdtrAcctId());
					pstm.setString(26, txInf.getCdtrAcctSchmeNm());
					pstm.setString(27, txInf.getCdtrAgtClrSysMmbId());
					pstm.setString(28, txInf.getCdtrAgtBICFI());
					pstm.setString(29, null); //type
					pstm.setString(30, txInf.getPurpCd());
					pstm.setString(31, txInf.getPurpPrtry());
					pstm.setString(32, null);		//remittance info
					pstm.setDate(33, new java.sql.Date(new Date().getTime()));
					pstm.setTimestamp(34, new java.sql.Timestamp(new Date().getTime()));
					pstm.setString(35, busiSvrType);
					pstm.addBatch();
					
					if(count % BATCH_SIZE == 0)
					{
						pstm.executeBatch();
						pstm.clearBatch();
					}
				}
				pstm.executeBatch();
				con.commit();
			}
		}
		catch(Exception ex)
		{
			_logger.error(String.format("Temporarily persistent batch file[%s] data error", fileName), ex);
			con.rollback();
			throw ex;
		}
		finally
		{
			if(pstm != null)
				pstm.close();
		}
	}
	
	private FFPMsgVo_Pacs008 parse008(com.forms.ffp.adaptor.jaxb.iclfps.pacs_008_001_06.Document pacs008, String fileName) throws Exception 
	{
		FFPMsgVo_Pacs008 pacs008MsgVo = new FFPMsgVo_Pacs008();
		pacs008MsgVo.setMsgId(pacs008.getFIToFICstmrCdtTrf().getGrpHdr().getMsgId());
		pacs008MsgVo.setCreDtTm(pacs008.getFIToFICstmrCdtTrf().getGrpHdr().getCreDtTm().toString());
		String numberOfTx = pacs008.getFIToFICstmrCdtTrf().getGrpHdr().getNbOfTxs();
		pacs008MsgVo.setNbOfTxs(numberOfTx);
		pacs008MsgVo.setSttlmMtd(pacs008.getFIToFICstmrCdtTrf().getGrpHdr().getSttlmInf().getSttlmMtd().value());
		pacs008MsgVo.setClrSys(pacs008.getFIToFICstmrCdtTrf().getGrpHdr().getSttlmInf().getClrSys().getPrtry().value());
		List<CreditTransferTransaction251> list = pacs008.getFIToFICstmrCdtTrf().getCdtTrfTxInf();
		List<FFPMsgVO_Pacs008_CdtTrfTxInf> pacs008TxInf = new ArrayList<FFPMsgVO_Pacs008_CdtTrfTxInf>();
		pacs008MsgVo.setCdtTrfTxInfList(pacs008TxInf);
			
		//check message number
		if(numberOfTx.compareTo(String.valueOf(list.size())) != 0)
		{
			//logger
			//TBC, throw exception,the file data is invalid
			_logger.info(String.format("The numberOfTx[%s] not match with the actual Transaction messages[%s] in the bizData of file[fileName:%s]", 
														numberOfTx, list.size(), fileName));
			throw new Exception("The numberOfTx not match with the actual Transaction messages in the file");
		}
			
		for(CreditTransferTransaction251 ct251 : list)
		{
			FFPMsgVO_Pacs008_CdtTrfTxInf cdtTxInfo = new FFPMsgVO_Pacs008_CdtTrfTxInf();
			pacs008TxInf.add(cdtTxInfo);
			cdtTxInfo.setInstrId(ct251.getPmtId().getInstrId());
			cdtTxInfo.setEndToEndId(ct251.getPmtId().getEndToEndId());
			cdtTxInfo.setTxId(ct251.getPmtId().getTxId());
			cdtTxInfo.setClrSysRef(ct251.getPmtId().getClrSysRef());
			//payment type information
			if(ct251.getPmtTpInf() != null && ct251.getPmtTpInf().getLclInstrm() != null)
			{
				cdtTxInfo.setLclInstrm(ct251.getPmtTpInf().getLclInstrm().getPrtry().value()); //FPS skip this verification for received mode is batch
				if(ct251.getPmtTpInf().getCtgyPurp() != null)
				{
					cdtTxInfo.setCtgyPurp(ct251.getPmtTpInf().getCtgyPurp().getPrtry().value());
				}
			}
				
			cdtTxInfo.setIntrBkSttlmAmt(String.valueOf(ct251.getIntrBkSttlmAmt().getValue()));
			cdtTxInfo.setIntrBkSttlmAmtCcy(ct251.getIntrBkSttlmAmt().getCcy().value());
				
			if(ct251.getIntrBkSttlmDt() != null)
			{
				cdtTxInfo.setIntrBkSttlmDt(ct251.getIntrBkSttlmDt().toString());
			}
			if(ct251.getSttlmTmIndctn() != null && ct251.getSttlmTmIndctn().getCdtDtTm() != null)
			{
				cdtTxInfo.setCdtDtTm(ct251.getSttlmTmIndctn().getCdtDtTm().toString());
			}
			if(ct251.getInstdAmt() != null)
			{
				cdtTxInfo.setInstdAmt(String.valueOf(ct251.getInstdAmt().getValue()));
				cdtTxInfo.setInstdAmtCcy(ct251.getInstdAmt().getCcy().value());
			}
				
			//charge info.
			cdtTxInfo.setChrgBr(ct251.getChrgBr().value());
			//TBC
			if(ct251.getChrgsInf() != null)
			{
				ChargeInfo chrgInfo = cdtTxInfo.new ChargeInfo();
				if(ct251.getChrgsInf().getAmt() != null)
				{
					chrgInfo.setChrgsInfAmt(String.valueOf(ct251.getChrgsInf().getAmt().getValue()));
					chrgInfo.setChrgsInfCcy(ct251.getChrgsInf().getAmt().getCcy().value());
				}
				chrgInfo.setChrgsInfAgtBICFI(ct251.getChrgsInf().getAgt().getFinInstnId().getBICFI());
				chrgInfo.setChrgsInfAgtClrSysId(ct251.getChrgsInf().getAgt().getFinInstnId() != null ? ct251.getChrgsInf().getAgt().getFinInstnId().getClrSysMmbId().getMmbId() : null);
			}
				
			//Debtor
			cdtTxInfo.setDbtrNm(ct251.getDbtr().getNm());
			if(ct251.getDbtr().getId() != null)
			{
				if(ct251.getDbtr().getId().getOrgId().getAnyBIC() != null) cdtTxInfo.setDbtrOrgIdAnyBIC(ct251.getDbtr().getId().getOrgId().getAnyBIC());
				GenericOrganisationIdentification11 other = ct251.getDbtr().getId().getOrgId().getOthr();
				if(other != null) //0..*,maybe a collection
				{
					DbtrOrgIdOth dbtrOrgOth = cdtTxInfo.new DbtrOrgIdOth();
					List<DbtrOrgIdOth> dbtrOrgOthList = new ArrayList<DbtrOrgIdOth>();
					dbtrOrgOth.setDbtrOrgIdId(other.getId());
					dbtrOrgOth.setDbtrOrgIdSchmeNm(other.getSchmeNm() != null ? other.getSchmeNm().getCd().value() : null);
					dbtrOrgOth.setDbtrOrgIdIssr(other.getIssr() != null ? other.getIssr() : null);
					dbtrOrgOthList.add(dbtrOrgOth);
					cdtTxInfo.setDbtrOrgOthers(dbtrOrgOthList);
				}
					
				GenericPersonIdentification11 prvtOther = ct251.getDbtr().getId().getPrvtId().getOthr();
				if(prvtOther != null)
				{
					DbtrPrvtIdOth dbtrPrvtOth = cdtTxInfo.new DbtrPrvtIdOth();
					List<DbtrPrvtIdOth> dbtrPrvtOthList = new ArrayList<DbtrPrvtIdOth>();
					dbtrPrvtOth.setDbtrPrvtIdId(prvtOther.getId());
					dbtrPrvtOth.setDbtrPrvtIdSchmeNm(prvtOther.getSchmeNm() != null ? prvtOther.getSchmeNm().getCd().value() : null);
					dbtrPrvtOth.setDbtrPrvtIdIssr(prvtOther.getIssr() != null ? prvtOther.getIssr() : null);
					dbtrPrvtOthList.add(dbtrPrvtOth);
					cdtTxInfo.setDbtrPrvtOthers(dbtrPrvtOthList);
				}
			}
				
			cdtTxInfo.setDbtrMobNb(ct251.getDbtr().getCtctDtls() != null ? ct251.getDbtr().getCtctDtls().getMobNb() : null);
			cdtTxInfo.setDbtrEmailAdr(ct251.getDbtr().getCtctDtls() != null ? ct251.getDbtr().getCtctDtls().getEmailAdr() : null);
				
			//Debtor Account and Debtor Agent
			CashAccount241 dbtAcc = ct251.getDbtrAcct();
			BranchAndFinancialInstitutionIdentification51 dbtAgt = ct251.getDbtrAgt();
			if(dbtAcc != null)
			{
				cdtTxInfo.setDbtrAcctId(dbtAcc.getId().getOthr().getId());
				cdtTxInfo.setDbtrAccSchmeNm(dbtAcc.getId().getOthr().getSchmeNm() != null ? dbtAcc.getId().getOthr().getSchmeNm().getPrtry().value() : null);
			}
				
			if(dbtAgt != null)
			{
				cdtTxInfo.setDbtrAgBICFI(dbtAgt.getFinInstnId().getBICFI());
				cdtTxInfo.setDbtrAgClrSysMmbId(dbtAgt.getFinInstnId().getClrSysMmbId() != null ? dbtAgt.getFinInstnId().getClrSysMmbId().getMmbId() : null);
			}
				
			//Creditor Agent
			BranchAndFinancialInstitutionIdentification51 cdtrAgt = ct251.getCdtrAgt();
			if(cdtrAgt != null)
			{
				cdtTxInfo.setCdtrAgtBICFI(cdtrAgt.getFinInstnId().getBICFI());
				cdtTxInfo.setCdtrAgtClrSysMmbId(cdtrAgt.getFinInstnId().getClrSysMmbId() != null ? cdtrAgt.getFinInstnId().getClrSysMmbId().getMmbId() : null);
			}
			//Creditor
			cdtTxInfo.setCdtrNm(ct251.getCdtr().getNm());
			if(ct251.getCdtr().getId() != null)
			{
				cdtTxInfo.setCdtrOrgIdAnyBIC(ct251.getCdtr().getId().getOrgId().getAnyBIC());
				GenericOrganisationIdentification11 other = ct251.getCdtr().getId().getOrgId().getOthr();
				if(other != null) //0..*,maybe a collection
				{
					CdtrOrgIdOth cdtrOrgOth = cdtTxInfo.new CdtrOrgIdOth();
					List<CdtrOrgIdOth> cdtrOrgOthList = new ArrayList<CdtrOrgIdOth>();
					cdtrOrgOth.setCdtrOrgIdId(other.getId());
					cdtrOrgOth.setCdtrOrgIdSchmeNm(other.getSchmeNm() != null ? other.getSchmeNm().getCd().value() : null);
					cdtrOrgOth.setCdtrOrgIdIssr(other.getIssr() != null ? other.getIssr() : null);
					cdtrOrgOthList.add(cdtrOrgOth);
					cdtTxInfo.setCdtrOrgOthers(cdtrOrgOthList);
				}
					
				GenericPersonIdentification11 prvtOther = ct251.getCdtr().getId().getPrvtId().getOthr();
				if(prvtOther != null)
				{
					CdtrPrvtIdOth cdtrPrvtOth = cdtTxInfo.new CdtrPrvtIdOth();
					List<CdtrPrvtIdOth> cdtrPrvtOthList = new ArrayList<CdtrPrvtIdOth>();
					cdtrPrvtOth.setCdtrPrvtIdId(prvtOther.getId());
					cdtrPrvtOth.setCdtrPrvtIdSchmeNm(prvtOther.getSchmeNm() != null ? prvtOther.getSchmeNm().getCd().value() : null);
					cdtrPrvtOth.setCdtrPrvtIdIssr(prvtOther.getIssr() != null ? prvtOther.getIssr() : null);
					cdtrPrvtOthList.add(cdtrPrvtOth);
					cdtTxInfo.setCdtrPrvtOthers(cdtrPrvtOthList);
				}
			}
				
			cdtTxInfo.setCdtrMobNb(ct251.getCdtr().getCtctDtls() != null ? ct251.getCdtr().getCtctDtls().getMobNb() : null);
			cdtTxInfo.setCdtrEmailAdr(ct251.getCdtr().getCtctDtls() != null ? ct251.getCdtr().getCtctDtls().getEmailAdr() : null);
				
			//Creditor Account
			CashAccount241 cbtrAcc = ct251.getCdtrAcct();
			if(cbtrAcc != null)
			{
				cdtTxInfo.setCdtrAcctId(cbtrAcc.getId().getOthr().getId());
				cdtTxInfo.setCdtrAcctSchmeNm(cbtrAcc.getId().getOthr().getSchmeNm() !=null ? cbtrAcc.getId().getOthr().getSchmeNm().getPrtry().value() : null);
			}
				
			//purpose
			if(ct251.getPurp() != null)
			{
				cdtTxInfo.setPurpCd(ct251.getPurp().getCd());
				cdtTxInfo.setPurpPrtry(ct251.getPurp().getPrtry());
			}
				
			//Remittance information
			if(ct251.getRmtInf() != null)
			{
				List<String> rmtList = new ArrayList<String>();
				rmtList.add(ct251.getRmtInf().getUstrd());
				cdtTxInfo.setRmtInf(rmtList);
			}
		}
			
		return pacs008MsgVo;
	}
	
	private Map<String, List<ISO20022BusinessDataV01>> readFile(List<File> fileList) throws Exception
	{
		//fileName:FPSPYCIkkkYYYYMMDDhhmmnnnn.xml
		//content:credit transfer(pacs008),return/refund(pacs004),notification(camt054)
		_logger.info("Started read inward batch file");
		Map<String, List<ISO20022BusinessDataV01>> validBusData = new HashMap<String, List<ISO20022BusinessDataV01>>();
		if(fileList != null)
		{
			//2. validate number of files in this batch time
			Map<String, FpsMessageEnvelope> validFiles = validateInwardFiles(fileList);
			
			Iterator<String> fileNameIt = validFiles.keySet().iterator();
			while(fileNameIt.hasNext())
			{
				
				String fileName = fileNameIt.next();
				FpsMessageEnvelope xmlFileData = validFiles.get(fileName);
				String batchId = xmlFileData.getBtchInf().getBtchId();
				String fileName_batchId = String.format("%s-%s", fileName, batchId);
				//3.validate message counts are correctly with each valid files
				String msgCount = xmlFileData.getNbOfMsgs();//get BizData count of each file
				List<ISO20022BusinessDataV01> bisDataList = xmlFileData.getFpsPylds().getBizData();
				if(msgCount.compareTo(String.valueOf(bisDataList.size())) != 0)
				{
					_logger.info(String.format("The file contains invalid message counts:FileName[%s]-NoOfMsgs[%s]-ActualMegsCount[%s]", 
														fileName, msgCount, String.valueOf(bisDataList.size())));
				}
				else
				{
					validBusData.put(fileName_batchId, bisDataList);
				}
			}
			
			_logger.info("Ended read inward batch file");
		}
		return validBusData;
	}
	
	//Remove invalid files which batchId & numberOfFile not match with the actual number of file.
	public Map<String, FpsMessageEnvelope> validateInwardFiles(List<File> fileList) throws Exception
	{
		if(fileList.size() == 0) return new HashMap<String, FpsMessageEnvelope>();
		Map<String, FpsMessageEnvelope> validFileData = new HashMap<String, FpsMessageEnvelope>();
		Map<String, FpsMessageEnvelope> mapFile = new HashMap<String, FpsMessageEnvelope>();
		List<String> keyCount = new ArrayList<String>();
		
		for(File xmlFile : fileList)
		{
			try
			{
				FpsMessageEnvelope result = FFPHkiclMessageConverter.parseObject(xmlFile);
				
				BatchInformation batchInfo = result.getBtchInf();
				String batchID = batchInfo.getBtchId();
				String numberOfFile = batchInfo.getNbOfFls();
				//check batchId & numberOfFile, maybe numberOfFile>1, so more than one file contains the same batch ID.
				String keyFileIdStr = String.format("BatchId[%s]-NumberOfFile[%s]-fileName[%s]", batchID, numberOfFile, xmlFile.getName());
				String keyCountStr = String.format("BatchId[%s]-NumberOfFile[%s]", batchID, numberOfFile);
				_logger.info(String.format("File info:%s", keyFileIdStr));
				if(Integer.valueOf(numberOfFile) > 1)
				{
					mapFile.put(keyFileIdStr, result);
					keyCount.add(keyCountStr);
				}
				else
				{
					//add a single batch file
					validFileData.put(xmlFile.getName(), result);
				}
			}
			catch(Exception ex)
			{
				_logger.error(String.format("Error on parsing file[fileName:%s]",xmlFile.getName()), ex);
				throw ex;
			}
			
		}
		
		Comparator<String> comp = new Comparator<String>() {

			@Override
			public int compare(String arg0, String arg1) {
				return arg0.compareTo(arg1);
			}
		}; 
		
		Collections.sort(keyCount, comp);
		
		//Calculate count
		Map<String, Integer> countMap = new HashMap<String, Integer>();
		for(String str : keyCount)
		{
			if(countMap.containsKey(str)) countMap.put(str, countMap.get(str) + 1);
			else countMap.put(str, 1);
		}
		
		//Remove invalid file
		List<String> validKey = new ArrayList<String>();
		Iterator<String> iteStr = countMap.keySet().iterator();
		while(iteStr.hasNext())
		{
			String countKey = iteStr.next();
			Integer countValue = countMap.get(countKey);
			//whether count matches file No. or not
			if(countKey.substring(countKey.lastIndexOf("[") + 1, countKey.lastIndexOf("]")).compareTo(String.valueOf(countValue)) != 0)
			{
				//Not match
				_logger.info(String.format("The files contain %s not matched with actual number of files!", countKey));
			}
			else
			{
				validKey.add(countKey);//add matched key info. of files
			}
		}
		
		
		Iterator<String> iter = mapFile.keySet().iterator();
		while(iter.hasNext())
		{
			String key = iter.next();
			if(validKey.contains(key.substring(0, key.lastIndexOf("-"))))
			{
				validFileData.put(key.substring(key.lastIndexOf("[") + 1, key.lastIndexOf("]")), mapFile.get(key));
			}
		}
		
		return validFileData;
	}
	
}
